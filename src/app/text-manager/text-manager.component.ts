import {
  Component,
  ChangeDetectionStrategy,
  Input,
  ViewChild,
  ElementRef
} from '@angular/core';
import {TextStyles} from '../models/text-styles';
import {generateKey, splitText} from './utils/text-manager.utils';

@Component({
  selector: 'app-text-manager',
  templateUrl: './text-manager.component.html',
  styleUrls: ['./text-manager.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class TextManagerComponent {
  @Input() text = '';

  @ViewChild('controls') controls: ElementRef;

  selectedIndexes = null;
  // to save already applied styles for phrases
  setStyles: {
    [key: string]: {
      bold?: boolean;
      italic?: boolean;
      underline?: boolean
    }
  } = {};

  /*
  * Reset indexes of highlighted text
  * */
  resetSelectedIndexes() {
    this.selectedIndexes = null;
  }

  /*
  * Detect and set indexes of highlighted text
  * @param e<MouseEvent> event of mouseup
  * */
  detectHighlightedIndexes(e: MouseEvent) {
    let text = '';
    let startIndex, endIndex;

    if (window.getSelection) {
      const selection = window.getSelection();
      text = selection.toString();
      startIndex = selection.anchorOffset;
      endIndex = selection.focusOffset;
    }

    if (text && text !== this.selectedIndexes) {
      this.controls.nativeElement.style.top = `${e.pageY}px`;
      this.controls.nativeElement.style.left = `${e.pageX}px`;
      this.selectedIndexes = [startIndex, endIndex];
    } else {
      this.selectedIndexes = null;
    }
  }

  /*
  * Handler for applying styles
  * @param style<TextStyles> style that have to be set to highlighted phrase
  * */
  onSetStyleHandler(style: TextStyles) {
    if (!style) {
      this.resetSelectedIndexes();
    }

    if (!this.selectedIndexes) {
      return;
    }

    const key = generateKey(this.selectedIndexes);
    if (!this.setStyles[key]) {
      this.setStyles[key] = {};
    }

    // TODO: have to be changed to innerText of div.text-manager to have correct substrings after added tags
    const parts = splitText(this.text, this.selectedIndexes);

    let changedPart;
    switch (style) {
      case TextStyles.bold:
        changedPart = this.setBold(key, parts[1]);
        break;
      case TextStyles.italic:
        changedPart = this.setItalic(key, parts[1]);
        break;
      case TextStyles.underline:
        changedPart = this.setUnderline(key, parts[1]);
    }

    parts[1] = changedPart;
    this.text = parts.join('');
    this.resetSelectedIndexes();
  }

  /*
  * Handler for applying Bold style
  * @param key<string> key generated by indexes of highlighted phrase
  * @param changeText<string> phrase that have to be changed
  * */
  setBold(key: string, changeText: string): string {
    this.setStyles[key].bold = !this.setStyles[key].bold;

    if (this.setStyles[key].bold) {
      return `<b>${changeText}</b>`;
    } else {
      // TODO: parse this.text to check that already was bold and remove b-tag for this phrase
    }
  }

  /*
  * Handler for applying Italic style
  * @param key<string> key generated by indexes of highlighted phrase
  * @param changeText<string> phrase that have to be changed
  * */
  setItalic(key: string, changeText: string): string {
    this.setStyles[key].italic = !this.setStyles[key].italic;

    if (this.setStyles[key].italic) {
      return `<i>${changeText}</i>`;
    } else {
      // TODO: parse this.text to check that already was italic and remove i-tag for this phrase
    }
  }

  /*
  * Handler for applying Underline style
  * @param key<string> key generated by indexes of highlighted phrase
  * @param changeText<string> phrase that have to be changed
  * */
  setUnderline(key: string, changeText: string): string {
    this.setStyles[key].underline = !this.setStyles[key].underline;

    if (this.setStyles[key].underline) {
      return `<u>${changeText}</u>`;
    } else {
      // TODO: parse this.text to check that already was underline and remove u-tag for this phrase
    }
  }
}
